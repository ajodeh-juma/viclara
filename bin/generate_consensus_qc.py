#!/usr/bin/env python3

"""
QC for consensus FASTA file generated by ivar consensus
outputs a csv file containing a final column 'qc_pass' 
with the rows for each sample indicated by the string 'TRUE' 
if the overall QC check has passed or 'FALSE' if not.
"""

import os
import sys
import csv
import shlex
import argparse
import subprocess
from itertools import groupby


def parse_args():
    """
    command line arguments parser
    """

    class CustomFormatter(argparse.ArgumentDefaultsHelpFormatter, argparse.RawDescriptionHelpFormatter):
        pass

    parser = argparse.ArgumentParser(prog='generate_consensus.py',
                                     description=__doc__,
                                     formatter_class=CustomFormatter,
                                     )
    required_group = parser.add_argument_group('Mandatory')
    required_group.add_argument('--prefix', type=str, dest="sample", required=True,
                                help="prefix or sample name"
                                )
    required_group.add_argument('--bam', type=str, dest='bamfile', required=True,
                                help="Alignment file in BAM format"
                                )
    required_group.add_argument('--reference', type=str, dest='reference', required=True,
                                help='Reference file in FASTA format'
                                )
    required_group.add_argument('--consensus-fasta', type=str, dest='fasta', required=True,
                                help='Consensus file in FASTA format'
                                )
    required_group.add_argument('--outfile', type=str, dest='outfile', required=True,
                                help='output filename'
                                )
    parser.add_argument('--min-depth', type=int, dest='min_depth', default=10,
                        help='Minimum depth threshold for determining the coverage'
                             '(number of bases covered) in the consensus fasta'
                        )
    parser.add_argument('--ngap', type=int, dest='n_gap',
                        help='Maximum number of Ns gap allowed in the consensus file, default is a third of the '
                             'length of the consensus '
                        )
    parser.add_argument('--npct', type=float, dest='n_pct', default=50.0,
                        help='Percentage of Ns allowed in the consensus file'
                        )
    return parser


def collect_depths(bamfile):
    """
    Compute the depth per position including zero depth positions

    :param bamfile: Alignment file in BAM format
    :return  
    """

    depths = dict()
    max_coverage = 0
    call = "samtools depth -a -d {} {}".format(max_coverage, bamfile)
    cmd = shlex.split(call)
    try:
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True)
        out, err = p.communicate()
        for ln in out.split("\n"):
            if ln:
                contig, pos, depth = ln.split("\t")
                key = contig + ' ' + pos
                depths[key] = int(depth)
    except (subprocess.CalledProcessError, OSError) as error:
        print(error)
    return depths


def get_paired_alignments(bamfile):
    """
    Given a bam file, this function runs samtools view to extract paired alignments
    Returns an integer
    :param bamfile: Alignment file in BAM format
    :return integer
    """
    filter_flag = '0x900'  # for extracting mapped paired alignments
    call = ["samtools view -c -F{} {}".format(filter_flag, bamfile)]
    cmd = " ".join(call)
    try:
        p = subprocess.check_output(cmd, shell=True)
        aligned_reads = p.decode().strip()
        return aligned_reads
    except (subprocess.CalledProcessError, OSError) as error:
        print(error)


def fasta_iterator(fa):
    """
    Given a fasta file. yield tuples of header, sequence
    :param fa FASTA file
    """
    fa_fh = open(fa)
    faiter = (x[1] for x in groupby(fa_fh, lambda line: line[0] == ">"))
    for header in faiter:
        header = next(header)[1:].strip()
        seq = "".join(s.strip() for s in next(faiter))
        yield header, seq
    fa_fh.close()


def compute_coverage(depths, min_depth, reference):
    """
    get coverage of the consensus fasta file based on the minimum depth threshold
    :param depths: dictionary of the coverage depths for each position in the alignment bam file
    :param min_depth: integer value for the minimum depth
    :param reference: reference file in fasta format
    :return tuple of coverage (int) and percentage of coverage (float)
    """
    positions_covered = 0
    # loop through the depths dict and get positions >= min depth
    for contig_pos, depth in depths.items():
        if depth >= min_depth:
            positions_covered += 1

    # read reference file and compute percentage coverage
    seqs = list(fasta_iterator(reference))
    seqid, seqstr = seqs[0]
    perc_coverage = positions_covered / len(seqstr) * 100
    return positions_covered, perc_coverage


def compute_N_stats(sample, consensus, n_gap, n_pct):
    """
    Given a consensus file with masked bases (N) in FASTA format, this function
    computes the masked positions statistics
    :param sample: prefix to the sample name 
    :param consensus: Masked consensus sequnec file in FASTA format
    :param n_gap: Maximum N gap allowed
    :param n_pct: Minimum percentage of N 
    """

    n_positions = list()

    # yield seqid, sequence
    seqs = list(fasta_iterator(consensus))
    seqid, seqstr = seqs[0]

    largest_n_gap = 0
    perc_n = 0
    qc_pass = "FALSE"

    if len(seqstr) != 0:
        # extract positions with N's
        n_positions = [index for index, base in enumerate(seqstr.lower()) if base == "n"]

        # compute percentage of N's
        perc_n = len(n_positions) / len(seqstr) * 100

        # get largest gap of Ns
        n_positions = [0] + n_positions + [len(seqstr)]

        without_first = n_positions[1:]
        without_last = n_positions[:-1]

        n_gaps = list()
        for i, j in zip(without_last, without_first):
            n_gaps.append(j - i)
        largest_n_gap = sorted(n_gaps)[-1]

        if n_gap is None:
            n_gap = int(1 / 3 * len(seqstr))

        if largest_n_gap >= n_gap or perc_n < n_pct:
            qc_pass = "TRUE"
    return perc_n, largest_n_gap, qc_pass


def write_to_csv(sample, perc_n, perc_coverage, largest_n_gap, aligned_reads, consensus, bamfile, qc_pass, outfile):
    """
    Write to csv file
    """
    qc_line = {'sample_name': sample,
               'pct_N_bases': "{:.2f}".format(perc_n),
               'pct_covered_bases': "{:.2f}".format(perc_coverage),
               'longest_no_N_run': largest_n_gap,
               'num_aligned_reads': aligned_reads,
               'fasta': consensus,
               'bam': bamfile,
               'qc_pass': qc_pass}

    print(qc_line)
    with open(outfile, 'w') as csvfile:
        header = qc_line.keys()
        writer = csv.DictWriter(csvfile, fieldnames=header)
        writer.writeheader()
        writer.writerow(qc_line)


def main():
    """
    """
    parser = parse_args()
    args = parser.parse_args()
    if args.outfile is None:
        print("please specify the output file")
        sys.exit(2)
    depths = collect_depths(bamfile=args.bamfile)
    aligned_reads = get_paired_alignments(bamfile=args.bamfile)
    positions_covered, perc_coverage = compute_coverage(depths=depths, min_depth=args.min_depth,
                                                        reference=args.reference)
    perc_n, largest_n_gap, qc_pass = compute_N_stats(sample=args.sample, consensus=args.fasta, n_gap=args.n_gap,
                                                     n_pct=args.n_pct)

    write_to_csv(sample=args.sample,
                 perc_n=perc_n,
                 perc_coverage=perc_coverage,
                 largest_n_gap=largest_n_gap,
                 aligned_reads=aligned_reads,
                 consensus=args.fasta,
                 bamfile=args.bamfile,
                 qc_pass=qc_pass,
                 outfile=args.outfile
                 )


if __name__ == '__main__':
    main()
