#!/usr/bin/env python3


# --- standard imports ---#
import os
import re
import sys
import shutil
import logging
import argparse
import textwrap
import functools
from pathlib import Path

maketrans = str.maketrans
from collections import namedtuple
from textwrap import dedent

# --- third-party imports ---#
import pandas as pd

from utils import fasta_iterator

TilingContig = namedtuple('TilingContig', [
    'ref_name', 'ref_start', 'ref_end', 'gap2next',
    'len', 'aln_cov', 'perc_ident', 'ori', 'name'])


def parse_args():
    """command line options"""

    class CustomFormatter(argparse.ArgumentDefaultsHelpFormatter, argparse.RawDescriptionHelpFormatter):
        pass

    parser = argparse.ArgumentParser(
        formatter_class=CustomFormatter,
        # formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        prefix_chars='-',
        description=__doc__
    )

    required_group = parser.add_argument_group(dedent('''mandatory arguments'''))
    required_group.add_argument('-r', '--reference', metavar='<FILE>', required=True,
                                dest='reference_fasta',
                                help="path to the reference FASTA file"
                                )
    required_group.add_argument('-t', '--tiling', metavar='<FILE>', required=True,
                                dest='tiling_file',
                                help="path to the tiling.txt file generated by MUMmer' show-tiling method"
                                )
    required_group.add_argument('-c', '--contigs', metavar='<FILE>', required=True,
                                dest='contigs_fasta',
                                help="path to the contigs FASTA file generated by assembler"
                                )
    required_group.add_argument('-s', '--sample', type=str, metavar='<str>', required=True,
                                dest='sample',
                                help="name of the sample"
                                )
    # required_group.add_argument('-b', '--bed', metavar='<FILE>', required=True,
    #                             dest='bed_file',
    #                             help="output filename for the gap-filled bed file"
    #                             )
    # required_group.add_argument('-o', '--outfile', metavar='<FILE>', required=True,
    #                             dest='outfile',
    #                             help="output filename for the gap-filled assembly FASTA file"
    #                             )
    return parser


def split_tiling(tiling_file, sample):
    """

    :param tiling_file:
    :return:
    """

    temp_files = []

    # get all the tiling data for each segment
    segments_tiling_dict = dict()
    segments_tiling_files = dict()

    with open(tiling_file, 'r') as f_obj:
        for line in f_obj:
            if line.startswith('>'):
                header = sample + ' ' + str(line.split()[0].strip('>')) + ' ' + str(line.split()[1])
                segments_tiling_dict[header] = []
            else:
                tiling_data = "".join(line.strip())
                if header not in segments_tiling_dict:
                    segments_tiling_dict[header] += tiling_data
                else:
                    segments_tiling_dict[header].append(tiling_data)

    # write the tiling files to separate files as per reference segments
    for contig, records in segments_tiling_dict.items():
        prefix = "_".join(contig.rsplit(' ')[:2])
        out_tiling = prefix + '.tiling.txt'

        with open(out_tiling, 'w') as f_obj:
            f_obj.write('>' + " ".join(contig.rsplit(' ')[1:]) + ' bases' + '\n')
            f_obj.write("\n".join(records) + '\n')
        segments_tiling_files[contig] = out_tiling

        temp_files.append(out_tiling)

    # create dataframe
    segments_tiling_df = pd.DataFrame(list(segments_tiling_files.items()),
                                      columns=['header', 'ref_tiling'])
    segments_tiling_df.dropna(inplace=True)

    # split the sample column and rename then drop old sample column
    new = segments_tiling_df["header"].str.split(" ", n=2, expand=True)
    segments_tiling_df["sample"] = new[0]
    segments_tiling_df["ref_accession"] = new[1]
    segments_tiling_df["ref_length"] = new[2]
    segments_tiling_df.drop(columns=["header"], inplace=True)
    return segments_tiling_dict, segments_tiling_df, temp_files


def split_contigs_fasta(contigs_fasta, segments_tiling_dict, sample):
    """

    :param contigs_fasta:
    :param segments_tiling_dict:
    :param sample:
    :param out_dir:
    :return:
    """

    #
    temp_files = []

    segments_contigs_dict = dict()
    segments_contigs_files = dict()

    # iterate through the contigs fasta file
    with open(contigs_fasta, 'r') as f_obj:
        for line in f_obj:
            if line.startswith('>'):
                header = sample + ' ' + str(line.split()[0].strip('>'))
                segments_contigs_dict[header] = ''
            else:
                seq = "".join(line.strip())
                segments_contigs_dict[header] += seq

    # extract the contigs from assembly by comparing to the tiling file
    for k, v in segments_tiling_dict.items():
        prefix = "_".join(k.rsplit(' ')[:2])
        out_contigs = prefix + '.contigs.fasta'
        segments_contigs_files[" ".join(k.rsplit(' ')[:2])] = out_contigs
        with open(out_contigs, 'w') as f_obj:
            for c in v:
                seq_id = list(c.split('\t'))[-1]
                sequence = segments_contigs_dict.get(k.rsplit(' ')[0] + ' ' + seq_id)
                f_obj.write((">{}\n{}\n".format(seq_id, textwrap.fill(sequence, width=80))))
        temp_files.append(out_contigs)

    # create a dataframe for the segments contigs files
    segments_contigs_df = pd.DataFrame(list(segments_contigs_files.items()), columns=['header', 'contig'])
    # split the sample column and rename then drop old sample column
    new = segments_contigs_df["header"].str.split(" ", n=1, expand=True)
    segments_contigs_df["sample"] = new[0]
    segments_contigs_df["ref_accession"] = new[1]
    segments_contigs_df.drop(columns=["header"], inplace=True)
    return segments_contigs_df, temp_files


def split_reference(reference):
    """

    :param reference:
    :param out_dir:
    :return:
    """

    temp_files = []
    # iterate through reference sequences if segmented and write individual segments to files
    d = dict((x[0].split()[0], x[1]) for x in fasta_iterator(fasta_name=reference))

    segments_ref_files = dict()
    for k, v in d.items():
        segment_ref_out = k + '.ref.fasta'
        segments_ref_files[k] = segment_ref_out
        with open(segment_ref_out, 'w') as f_obj:
            f_obj.write('>' + k + '\n')
            f_obj.write(v + '\n')
        temp_files.append(segment_ref_out)

    # create a dataframe for the reference segments
    segments_ref_df = pd.DataFrame(list(segments_ref_files.items()), columns=['ref_accession', 'ref'])
    return segments_ref_df, temp_files


def merge_dfs(tiling_df, contigs_df, refs_df):
    """
    merge multiple dataframes on common columns

    :param tiling_df:
    :param contigs_df:
    :param refs_df:
    :return:
    """

    df = functools.reduce(lambda left, right: pd.merge(left, right, on=['sample', 'ref_accession'], how='inner'),
                          [contigs_df, tiling_df])
    df = functools.reduce(lambda left, right: pd.merge(left, right, on='ref_accession', how='inner'),
                          [refs_df, df])
    d = df.set_index(df['sample'] + '_' + df['ref_accession']).T.to_dict('list')
    return d


def rev_comp(dna):
    """
    compute reverse complement for dna

    :param dna: DNA sequence

    No support for RNA.
    >>> rev_comp("AaGgCcTtNn")
    'nNaAgGcCtT'
    """

    # maketrans doc: "Don't use strings derived from lowercase and
    # uppercase as arguments; in some locales, these don't have the
    # same length. For case conversions, always use str.lower() and
    # str.upper()."
    old_chars = "ACGTN"
    old_chars += str.lower(old_chars)
    replace_chars = "TGCAN"
    replace_chars += str.lower(replace_chars)
    trans = maketrans(old_chars, replace_chars)
    return dna.translate(trans)[::-1]


def parse_tiling(tiling_file):
    """Parse Nucmer's tiling file and yields TilingContig's
    function returns refstart and refstart zero-based half open (i.e.
    in slice notation)
    From Mummers doc: Standard output has an 8 column list per
    mapped contig, separated by the FastA headers of each
    reference sequence. These columns are as follows: [1] start in
    the reference [2] end in the reference [3] gap between this
    contig and the next [4] length of this contig [5] alignment
    coverage of this contig [6] average percent identity of this
    contig [7] contig orientation [8] contig ID.

    """

    with open(tiling_file) as tile_fh:
        for line in tile_fh:
            if line.startswith(">"):
                ref_name = line[1:].split()[0].strip()
                continue
            (ref_start, ref_end, gap2next, contig_len, aln_cov, perc_ident, ori, name) = line.strip().split("\t")
            assert ori in "+-"
            (ref_start, ref_end, gap2next, contig_len) = (int(x) for x in (ref_start, ref_end, gap2next, contig_len))
            (aln_cov, perc_ident) = (float(x) for x in (aln_cov, perc_ident))
            ref_start -= 1  # refstart: 0-based, refend: exclusive
            yield TilingContig._make([
                ref_name, ref_start, ref_end, gap2next, contig_len,
                aln_cov, perc_ident, ori, name])


def write_seq(fn, sid, sq):
    fmt_sq = ">{}\n{}\n".format(sid, sq)
    if fn == "-":
        print(fmt_sq)
    else:
        with open(fn, 'w') as fh:
            fh.write((">{}\n{}\n".format(sid, textwrap.fill(sq, width=80))))


def write_bed(fn, coords):
    fmt_bed = "\n".join(["{:s}\t{:d}\t{:d}".format(
        c[0], c[1], c[2]) for c in coords])
    fmt_bed += "\n"

    if fn == "-":
        print(fmt_bed)
    else:
        with open(fn, 'w') as fh:
            fh.write(fmt_bed)


def merge_contigs_and_ref(contig_seqs, ref_seq, tiling_file, out_file, seqid,
                          gapfill_bed_file):
    """
    merge contigs and reference based tiling data

    :param contig_seqs:
    :param ref_seq:
    :param tiling_file:
    :param out_file:
    :param seqid:
    :param gapfill_bed_file:
    :return:
    """

    temp_files = []

    # gapfill_bed_out = os.path.join(out_dir, sample + '-gap-filled-assembly-gaps.bed')

    # iterate through the reference sequence to get sequence header sequence dict
    ref_seq = dict((x[0].split()[0], x[1]) for x in fasta_iterator(fasta_name=ref_seq))
    assert len(ref_seq) == 1, "Only one reference sequence supported for N filling"

    # iterate though the contigs sequence to get sequence header sequence dict
    contig_seqs = dict((x[0].split()[0], x[1]) for x in fasta_iterator(fasta_name=contig_seqs))

    bed_coords = []
    out_seq = ""

    last_refend = 0  # exclusive
    contig = None
    last_refname = None

    for contig in parse_tiling(tiling_file):
        assert contig.ref_name in ref_seq, ("Tiling reference name '{}' not found in refseqs".format(contig.ref_name))
        assert contig.ref_name == last_refname or last_refname is None, "No support for multiple references"
        last_refname = contig.ref_name

        # if there was a gap before this contig, fill with reference
        if contig.ref_start > last_refend:
            logging.info("ref %s+1:%s", last_refend, contig.ref_start)
            sq = ref_seq[contig.ref_name][last_refend:contig.ref_start]
            bed_coords.append([seqid, len(out_seq), len(out_seq) + len(sq)])
            out_seq += sq
        # if there's overlap with the next contig we clip the current one (assumes all contigs are equally good)
        printto = None
        if contig.gap2next < 0:
            printto = contig.gap2next

        if contig.ori == '+':
            logging.info("con+ %s+1:%s", 0, printto)
            sq = contig_seqs[contig.name][:printto]

            out_seq += sq
        elif contig.ori == '-':
            logging.info("con- %s+1:%s", 0, printto)
            sq = rev_comp(contig_seqs[contig.name])[:printto]
            out_seq += sq
        else:
            raise ValueError(contig.ori)
        last_refend = contig.ref_end

    if contig is not None:
        if last_refend < len(ref_seq[contig.ref_name]):
            logging.info("ref %s+1:", last_refend)
            bed_coords.append([seqid, len(out_seq), len(out_seq) + len(sq)])
            sq = ref_seq[contig.ref_name][last_refend:]
            out_seq += sq
    else:
        logging.critical("Nothing to join")
        raise ValueError(tiling_file)

    write_seq(out_file, seqid, out_seq)

    # write gap filled bed co-ordinates
    write_bed(gapfill_bed_file, bed_coords)
    temp_files.append(out_file)
    return out_file


def main():
    parser = parse_args()
    args = parser.parse_args()

    til_dic, til_df, til_tmp = split_tiling(tiling_file=args.tiling_file, sample=args.sample)
    contigs_df, contigs_tmp = split_contigs_fasta(contigs_fasta=args.contigs_fasta, segments_tiling_dict=til_dic,
                                                  sample=args.sample)
    refs_df, refs_tmp = split_reference(reference=args.reference_fasta)
    d = merge_dfs(tiling_df=til_df, contigs_df=contigs_df, refs_df=refs_df)

    # merge contigs with reference based tiling data
    tmp_files = []
    for sample, records in d.items():
        seqid = records[0]
        ref_seq = records[1]
        contig_seqs = records[2]
        tiling_file = records[4]
        out_file = sample + '.gap.filled.assembly.fasta'
        gapfill_bed_file = sample + '.gap.filled.assembly.gaps.bed'

        s = merge_contigs_and_ref(contig_seqs=contig_seqs,
                                  ref_seq=ref_seq,
                                  tiling_file=tiling_file,
                                  out_file=out_file,
                                  seqid=seqid,
                                  gapfill_bed_file=gapfill_bed_file
                                  )

    # delete intermediate/temp files
    tmp_files.append((til_tmp + contigs_tmp + refs_tmp))
    for i in tmp_files:
        for f in i:
            os.unlink(f)
if __name__ == '__main__':
    main()
